diff --git tools/CMakeLists.txt tools/CMakeLists.txt
index 63822f2..a799482 100644
--- tools/CMakeLists.txt
+++ tools/CMakeLists.txt
@@ -14,7 +14,7 @@ set(LLVM_LINK_COMPONENTS
   objcarcopts)
 
 
-add_llvm_executable(seadsa DISABLE_LLVM_LINK_LLVM_DYLIB seadsa.cc)
+add_llvm_executable(seadsa DISABLE_LLVM_LINK_LLVM_DYLIB seadsa.cc ValidateAliasTests.cc)
 add_executable(libcSpecGen libcSpecGen.cc)
 
 target_link_libraries (seadsa PRIVATE SeaDsaAnalysis)
diff --git tools/ValidateAliasTests.cc tools/ValidateAliasTests.cc
new file mode 100644
index 0000000..9910ba3
--- /dev/null
+++ tools/ValidateAliasTests.cc
@@ -0,0 +1,136 @@
+// ==- ValidateAliasTests.cc - Validate alias checks from Test-Suite ==//
+
+#include "ValidateAliasTests.hh"
+#include "seadsa/SeaDsaAliasAnalysis.hh"
+
+#include "llvm/ADT/Optional.h"
+#include "llvm/Analysis/AliasAnalysis.h"
+#include "llvm/Analysis/MemoryLocation.h"
+#include "llvm/IR/DebugInfoMetadata.h"
+#include "llvm/IR/Instructions.h"
+#include "llvm/IR/Module.h"
+#include "llvm/Support/raw_ostream.h"
+
+#include <string>
+#include <unordered_set>
+
+using namespace llvm;
+using namespace seadsa;
+
+namespace {
+
+const std::unordered_set<std::string> &getAliasCheckNames() {
+  static const std::unordered_set<std::string> Names = {
+      "MAYALIAS", "NOALIAS", "MUSTALIAS", "PARTIALALIAS",
+      "_Z8MAYALIASPvS_", "_Z8MAYALIASPvS0_",
+      "_Z7NOALIASPvS_",  "_Z7NOALIASPvS0_",
+      "_Z9MUSTALIASPvS_", "_Z9MUSTALIASPvS0_",
+      "_Z12PARTIALALIASPvS_", "_Z12PARTIALALIASPvS0_",
+  };
+  return Names;
+}
+
+std::string formatSourceLoc(const Instruction *I) {
+  if (auto *DL = I->getDebugLoc().get()) {
+    if (auto *File = DL->getFile()) {
+      std::string filename = File->getFilename().str();
+      unsigned line = DL->getLine();
+      unsigned col = DL->getColumn();
+      return filename + ":" + std::to_string(line) + ":" + std::to_string(col);
+    }
+  }
+  return "(unknown)";
+}
+
+bool isAliasCheckCall(const Function *F) {
+  if (!F)
+    return false;
+  return getAliasCheckNames().count(F->getName().str()) != 0;
+}
+
+enum class CheckKind { MAYALIAS, NOALIAS, MUSTALIAS, PARTIALALIAS };
+
+llvm::Optional<CheckKind> getCheckKind(StringRef Name) {
+  if (Name == "MAYALIAS" || Name.startswith("_Z8MAYALIAS"))
+    return CheckKind::MAYALIAS;
+  if (Name == "NOALIAS" || Name.startswith("_Z7NOALIAS"))
+    return CheckKind::NOALIAS;
+  if (Name == "MUSTALIAS" || Name.startswith("_Z9MUSTALIAS"))
+    return CheckKind::MUSTALIAS;
+  if (Name == "PARTIALALIAS" || Name.startswith("_Z12PARTIALALIAS"))
+    return CheckKind::PARTIALALIAS;
+  return llvm::None;
+}
+
+bool checkSucceeded(CheckKind Kind, AliasResult Result) {
+  switch (Kind) {
+  case CheckKind::MAYALIAS:
+  case CheckKind::MUSTALIAS:
+    return Result == AliasResult::MayAlias || Result == AliasResult::MustAlias;
+  case CheckKind::NOALIAS:
+    return Result == AliasResult::NoAlias;
+  case CheckKind::PARTIALALIAS:
+    return Result == AliasResult::MayAlias || Result == AliasResult::PartialAlias;
+  }
+  return false;
+}
+
+const char *checkKindStr(CheckKind Kind) {
+  switch (Kind) {
+  case CheckKind::MAYALIAS:    return "MAYALIAS";
+  case CheckKind::NOALIAS:     return "NOALIAS";
+  case CheckKind::MUSTALIAS:   return "MUSTALIAS";
+  case CheckKind::PARTIALALIAS: return "PARTIALALIAS";
+  }
+  return "?";
+}
+
+} // namespace
+
+bool seadsa::runValidateAliasTests(Module &M, SeaDsaAAResult &AA) {
+  const DataLayout &DL = M.getDataLayout();
+  AAQueryInfo AAQI(nullptr);
+  bool anyFailure = false;
+
+  for (Function &F : M) {
+    for (BasicBlock &BB : F) {
+      for (Instruction &I : BB) {
+        auto *CI = dyn_cast<CallBase>(&I);
+        if (!CI)
+          continue;
+        const Function *Callee = CI->getCalledFunction();
+        if (!Callee || !isAliasCheckCall(Callee))
+          continue;
+        if (CI->arg_size() < 2)
+          continue;
+
+        llvm::Optional<CheckKind> Kind = getCheckKind(Callee->getName());
+        if (!Kind.hasValue())
+          continue;
+
+        Value *V1 = CI->getArgOperand(0);
+        Value *V2 = CI->getArgOperand(1);
+        
+        // Create MemoryLocation for each argument
+        MemoryLocation MemLoc1 = MemoryLocation::getBeforeOrAfter(V1);
+        MemoryLocation MemLoc2 = MemoryLocation::getBeforeOrAfter(V2);
+        
+        AliasResult Result = AA.alias(MemLoc1, MemLoc2, AAQI);
+        CheckKind KindVal = Kind.getValue();
+        bool success = checkSucceeded(KindVal, Result);
+        std::string Loc = formatSourceLoc(&I);
+
+        if (success) {
+          llvm::outs() << "\t SUCCESS :" << checkKindStr(KindVal)
+                       << " check at (" << Loc << ")\n";
+        } else {
+          llvm::errs() << "\t FAILURE :" << checkKindStr(KindVal)
+                       << " check at (" << Loc << ")\n";
+          anyFailure = true;
+        }
+      }
+    }
+  }
+
+  return !anyFailure;
+}
diff --git tools/ValidateAliasTests.hh tools/ValidateAliasTests.hh
new file mode 100644
index 0000000..b1d0c79
--- /dev/null
+++ tools/ValidateAliasTests.hh
@@ -0,0 +1,20 @@
+// ==- ValidateAliasTests.hh - Validate alias checks from Test-Suite ==//
+
+#pragma once
+
+namespace llvm {
+class Module;
+} // namespace llvm
+
+namespace seadsa {
+class SeaDsaAAResult;
+}
+
+namespace seadsa {
+
+/// Run alias-check validation: scan the module for MAYALIAS/NOALIAS/MUSTALIAS
+/// (and PARTIALALIAS) calls, query the built alias model, and print SUCCESS/FAILURE.
+/// \return false if any check failed (caller should exit(1)).
+bool runValidateAliasTests(llvm::Module &M, SeaDsaAAResult &AA);
+
+} // namespace seadsa
diff --git tools/seadsa.cc tools/seadsa.cc
index 06bc9db..c34d1c0 100644
--- tools/seadsa.cc
+++ tools/seadsa.cc
@@ -30,6 +30,7 @@
 #include "seadsa/ShadowMem.hh"
 #include "seadsa/support/Debug.h"
 #include "seadsa/support/RemovePtrToInt.hh"
+#include "ValidateAliasTests.hh"
 
 static llvm::cl::opt<std::string>
     InputFilename(llvm::cl::Positional,
@@ -180,7 +181,9 @@ int main(int argc, char **argv) {
 
   // -- add to pass manager
   pass_manager.add(seadsa::createDsaLibFuncInfoPass());
-  pass_manager.add(seadsa::createSeaDsaAAWrapperPass());
+  seadsa::SeaDsaAAWrapperPass *seaDsaAAPass = 
+      static_cast<seadsa::SeaDsaAAWrapperPass *>(seadsa::createSeaDsaAAWrapperPass());
+  pass_manager.add(seaDsaAAPass);
   // -- make available through AAResultsWrapperPass via ExternalAAWrapperPass
   pass_manager.add(llvm::createExternalAAWrapperPass(
       [](llvm::Pass &P, llvm::Function &, llvm::AAResults &AAR) {
@@ -236,6 +239,11 @@ int main(int argc, char **argv) {
 
   pass_manager.run(*module.get());
 
+  // Validate alias checks from Test-Suite
+  if (seaDsaAAPass && !runValidateAliasTests(*module.get(), seaDsaAAPass->getResult())) {
+    return 1;
+  }
+
   if (!AsmOutputFilename.empty()) asmOutput->keep();
 
   return 0;
